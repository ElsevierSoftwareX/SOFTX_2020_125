#!/usr/bin/env python
import argparse
import json
import shutil
from ligo import segments

"""
Methods used to convert JSON-payload data retrieved from the API server into 
other formats.

Formats - also known as 'output formats' - are distinguished as follows:
  - json:
    - not coalesced;
    - has both known and active (active first, then known);
    - see: https://segments-web.ligo.org/downloads/1552078659.json (787kB).
  - vdb:
    - coalesced;
    - this is a Virgo-defined format;
    - VDB stands for Virgo DataBase;
    - has separate datasets: 'known' (not active) and 'active' (which implies 
      'known') (active-and-known first (field #3 = 1), then search range 
      (field #3 = -1), then known-only (not active) (field #3 = 0))
    - so all points in time are part of 1 of 3 sets: unknown, known but not 
      active, or known and active; cf. coalesced json, where known and active 
      is a subset of known;
    - run "awk 'BEGIN { FS = ","; OFS = "," } ; { if ((NF==3) && ($3==1)) 
      print $1, $2 }'  infile.vdb  >  outfile.txt" to get known-and-active 
      segments, like in the ascii file format;
    - see: https://segments-web.ligo.org/downloads/1552078644.vdb (3kB).
  - ascii:
    - not coalesced;
    - has only active, not known;
    - identical to tsv, but comma separated values (ascii) is replaced by a 
      tab (tsv);
    - see: https://segments-web.ligo.org/downloads/1552078659.ascii (147kB).
  - coalesced_json:
    - coalesced;
    - has both known and active (known first, then active);
    - see: https://segments-web.ligo.org/downloads/1552078670.coalesced_json (2kB).
  - tsv:
    - not coalesced;
    - has only active, not known;
    - identical to ascii, but comma separating values (ascii) is replaced by 
      a tab (tsv);
    - see: https://segments-web.ligo.org/downloads/1552078679.tsv (147kB)
    
Descriptions last updated on the 18th of November, 2019, by Gary Hemming, 
courtesy of descriptions provided by Robert Bruntz.
"""


################################################################################
#
#  Conversions from JSON to user requested formats
#
################################################################################

def generated_vdb_ascii(json_dict,filepath):
    #res_dict=json.loads(json_str)
    res_dict=json_dict
    print(res_dict)
    active_list=res_dict['active']
    active_segments=segments.segmentlist([segments.segment(x[0],x[1]) for x in active_list])
    active_segments.coalesce()
    known_list=res_dict['known']
    known_segments=segments.segmentlist([segments.segment(x[0],x[1]) for x in known_list])
    known_segments.coalesce()
    query_start=res_dict['query_information']['start']
    query_stop=res_dict['query_information']['end']
    if query_start!=0 and query_stop!=0:
        requested_span=segments.segmentlist([segments.segment(query_start,query_stop)])
    else:
        requested_span=segments.segmentlist([segments.segment(0,9999999999)])
    active_segments_string=',1 \n'.join([str(i[0])+","+str(i[1]) for i in active_segments])+",1 \n"
    unknown_segments=requested_span-known_segments    
    unknown_segments_string=',-1 \n'.join([str(i[0])+","+str(i[1]) for i in unknown_segments])+",-1 \n"    
    known_not_active_segments=known_segments-active_segments
    known_not_active_segments_string=',0 \n'.join([str(i[0])+","+str(i[1]) for i in known_not_active_segments])+",0 \n"
    output_fileh=open(filepath,'a')
    query_info_string=json.dumps(res_dict['query_information'], indent=1)
    output_fileh.writelines(query_info_string)
    output_fileh.write('\n')
    output_fileh.writelines(active_segments_string)
    output_fileh.writelines(unknown_segments_string)
    output_fileh.writelines(known_not_active_segments_string)
    output_fileh.close()
    return filepath

def generated_ascii(json_dict, output_format):
    """
    Take the JSON dictionary returned by the API server and convert it so 
    that it provides only the active segments in an ASCII format.
    """
    # Init.
    r = ''
    # Loop through the JSON dictionary.
    for v in json_dict:
        # If the active list is not empty.
        if v['active']:
            # Get the segments into a LIGO segments structure. 
            s = segments.segmentlist([segments.segment(x[0],x[1]) for x in v['active']])
            # Coalesce them down.
            #s.coalesce()
            # Convert the segments into ASCII format.
            r = '\n'.join([str(i[0]) + "," + str(i[1]) for i in s])
    return r

def generated_json(json_dict,filepath):
    res_dict=json_dict
    active_list=res_dict['active']
    active_segments=convert_json_list_to_segmentlist(active_list)
    active_segments.coalesce()
    active_json=convert_segmentlist_to_json(active_segments)
    res_dict['active']=active_json

    known_list=res_dict['known']
    known_segments=convert_json_list_to_segmentlist(known_list)
    known_segments.coalesce()
    known_json=convert_json_list_to_segmentlist(known_segments)
    res_dict['known']=known_json
    #print filepath
    ### Document why we need the next line!:
    ### It is because the file name would be <number>.coalesced_json and we want it to be <number>.coalesced.json instead.  This breaks with normal file names given to command line though
    #filepath=".".join(["_".join(filepath.split("_")[0:-1]),filepath.split("_")[-1:][0]])
    #filepath='.'.join(filepath.split('_')[)
    #print filepath
    output_fileh=open(filepath,'a') 
    #output_fileh.writelines(active_segments_string) 
    json_output_string=json.dumps(res_dict)
    #print "Coalesced json string type"
    #print type(json_output_string)
    output_fileh.writelines(json_output_string)
    output_fileh.close()
    return filepath



##### 
#
# Ripped from jsonhelper.py in dqsegdb package until we can use it as a dependency
#
#####

def convert_segmentlist_to_json(segmentlist_input):
    """ 
    Helper function used to convert segmentlist to json list of lists type 
    object.
    """
    json_list=[[x[0],x[1]] for x in segmentlist_input]
    return json_list

def convert_json_list_to_segmentlist(jsonlist):
     """ 
     Helper function used to convert json list of lists type object to a 
     segmentlist object
     """
     segment_list=segments.segmentlist([segments.segment(x[0],x[1]) for x in jsonlist])
     return segment_list

#####
#
#  Set up parser for command line execution
#
######

def parse_command_line():
    """
    Set the args that can be passed by the user at the command line.
    """
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('jsonfile', type=str, help="Json input file.")
    parser.add_argument('-o', '--output', help="Output file path")
    parser.add_argument('-t', '--type', default='vdb', help='Type of file to ouput, default: %(default)s')
    args = parser.parse_args()
    return args

if __name__ == "__main__":
    args = parse_command_line()
    if args.type != 'vdb' and args.type != 'ascii' and args.type != 'coalesced_json':
        raise InputError('Please provide type of vdb or ascii or coalesced_json')
    try:
        json_dict = json.load(open(args.jsonfile))
    except:
        raise Error('Unable to load JSON file: %s' % (args.jsonfile))
    else:
        # Get the length of the dictionary passed.
        json_dict_len = len(json_dict)
        # Set the header, dependent upon the length of the dictionary.
        if json_dict_len == 1:
            hdr = 'One Flag-Version (%d) requested:\n' % (int(json_dict[0]['version']))
        else:
            hdr = '% Flag-Versions requested. %d results:\n' % (json_dict_len)
        # Handle ASCII-type conversion.
        if args.type == 'ascii':
            # Build the accumulative segment list.
            s = generated_ascii(json_dict, args.output)
        # Handle VDB-type conversion.
        elif args.type == 'vdb':
            s = generated_vdb_ascii(json_dict, args.output)
        # Handle Coalesced JSON conversion.
        elif args.type == 'coalesced_json':
            s = generated_json(json_dict, args.output)
        # Prefix the header to the results.
        r = hdr + s
        # Build the final filepath and dopy the results to it.
        filepath = args.output
        final_filepath = ".".join(["_".join(args.output.split("_")[0:-1]), args.output.split("_")[-1:][0]])
        shutil.copy(r, final_filepath)
        print("Output file %s created" % (r))
