#!/usr/bin/env python
import argparse
import json
import shutil
from ligo import segments

"""
Methods used to convert JSON-payload data retrieved from the API server into 
other user-requested formats.

Formats - also known as 'output formats' - are distinguished as follows:
  - json:
    - not coalesced;
    - has both known and active (active first, then known);
    - see: https://segments-web.ligo.org/downloads/1552078659.json (787kB).
  - vdb:
    - coalesced;
    - this is a Virgo-defined format;
    - VDB stands for Virgo DataBase;
    - has separate datasets: 'known' (not active) and 'active' (which implies 
      'known') (active-and-known first (field #3 = 1), then search range 
      (field #3 = -1), then known-only (not active) (field #3 = 0))
    - so all points in time are part of 1 of 3 sets: unknown, known but not 
      active, or known and active; cf. coalesced json, where known and active 
      is a subset of known;
    - run "awk 'BEGIN { FS = ","; OFS = "," } ; { if ((NF==3) && ($3==1)) 
      print $1, $2 }'  infile.vdb  >  outfile.txt" to get known-and-active 
      segments, like in the ascii file format;
    - see: https://segments-web.ligo.org/downloads/1552078644.vdb (3kB).
  - ascii:
    - not coalesced;
    - has only active, not known;
    - identical to tsv, but comma separated values (ascii) is replaced by a 
      tab (tsv);
    - see: https://segments-web.ligo.org/downloads/1552078659.ascii (147kB).
  - coalesced_json:
    - coalesced;
    - has both known and active (known first, then active);
    - see: https://segments-web.ligo.org/downloads/1552078670.coalesced_json (2kB).
  - tsv:
    - not coalesced;
    - has only active, not known;
    - identical to ascii, but comma separating values (ascii) is replaced by 
      a tab (tsv);
    - see: https://segments-web.ligo.org/downloads/1552078679.tsv (147kB)
    
Descriptions last updated on the 18th of November, 2019, by Gary Hemming, 
courtesy of descriptions provided by Robert Bruntz.

Last update, 18th of November, 2019, by Gary Hemming.
"""

def generate_vdb(json_dict,filepath):
    """
    Take a Flag-Version-Segments JSON dictionary and convert it so that it 
    so that it provides data in a VDB-style format.
    """
    # Init.
    r = ''
    # Loop through the JSON dictionary.
    for v in json_dict:
        # If the active list is not empty.
        if v['active']:
            # Get the segments into a LIGO segments structure. 
            sa = segments.segmentlist([segments.segment(x[0],x[1]) for x in v['active']])
            # Coalesce the segments.
            sa.coalesce()
        # If the known list is not empty.
        if v['known']:
            # Get the segments into a LIGO segments structure. 
            sk = segments.segmentlist([segments.segment(x[0],x[1]) for x in v['known']])
            # Coalesce the segments.
            sk.coalesce()
    return r
    #res_dict=json.loads(json_str)
    res_dict=json_dict
    print(res_dict)
    active_list=res_dict['active']
    active_segments=segments.segmentlist([segments.segment(x[0],x[1]) for x in active_list])
    active_segments.coalesce()
    known_list=res_dict['known']
    known_segments=segments.segmentlist([segments.segment(x[0],x[1]) for x in known_list])
    known_segments.coalesce()
    
    query_start=res_dict['query_information']['start']
    query_stop=res_dict['query_information']['end']
    if query_start!=0 and query_stop!=0:
        requested_span=segments.segmentlist([segments.segment(query_start,query_stop)])
    else:
        requested_span=segments.segmentlist([segments.segment(0,9999999999)])
    active_segments_string=',1 \n'.join([str(i[0])+","+str(i[1]) for i in active_segments])+",1 \n"
    unknown_segments=requested_span-known_segments    
    unknown_segments_string=',-1 \n'.join([str(i[0])+","+str(i[1]) for i in unknown_segments])+",-1 \n"    
    known_not_active_segments=known_segments-active_segments
    known_not_active_segments_string=',0 \n'.join([str(i[0])+","+str(i[1]) for i in known_not_active_segments])+",0 \n"
    output_fileh=open(filepath,'a')
    query_info_string=json.dumps(res_dict['query_information'], indent=1)
    output_fileh.writelines(query_info_string)
    output_fileh.write('\n')
    output_fileh.writelines(active_segments_string)
    output_fileh.writelines(unknown_segments_string)
    output_fileh.writelines(known_not_active_segments_string)
    output_fileh.close()
    return filepath

def generate_ascii_tsv(json_dict, output_format):
    """
    Take a Flag-Version-Segments JSON dictionary and convert it so that it 
    provides only the active segments in an ASCII or tab-separated-value 
    format.
    """
    # Init.
    s = []
    r = ''
    # Loop through the JSON dictionary.
    for v in json_dict:
        # If the active list is not empty.
        if v['active']:
            # Get the segments into a LIGO segments structure. 
            s.extend(segments.segmentlist([segments.segment(x[0],x[1]) for x in v['active']]))
    # If the active segment-list has been built.
    if s:
        # Coalesce the segments.
        s.coalesce()
        # Use a comma to divide the segment times.
        if output_format == 'ascii':
            d = ','
        # Use the tab character to divide the segment times.
        elif output_format == 'tsv':
            d = '\t'
        # Break the segments down by line, using the defined divider.
        r = '\n'.join([str(i[0]) + d + str(i[1]) for i in s])
    return r

def generate_coalesced_json(json_dict,filepath):
    """
    Take a Flag-Version-Segments JSON dictionary, coalesce the segments and 
    return it as a new JSON dictionary.
    """
    res_dict=json_dict
    active_list=res_dict['active']
    active_segments=convert_json_list_to_segmentlist(active_list)
    active_segments.coalesce()
    active_json=convert_segmentlist_to_json(active_segments)
    res_dict['active']=active_json

    known_list=res_dict['known']
    known_segments=convert_json_list_to_segmentlist(known_list)
    known_segments.coalesce()
    known_json=convert_json_list_to_segmentlist(known_segments)
    res_dict['known']=known_json
    #print filepath
    ### Document why we need the next line!:
    ### It is because the file name would be <number>.coalesced_json and we want it to be <number>.coalesced.json instead.  This breaks with normal file names given to command line though
    #filepath=".".join(["_".join(filepath.split("_")[0:-1]),filepath.split("_")[-1:][0]])
    #filepath='.'.join(filepath.split('_')[)
    #print filepath
    output_fileh=open(filepath,'a') 
    #output_fileh.writelines(active_segments_string) 
    json_output_string=json.dumps(res_dict)
    #print "Coalesced json string type"
    #print type(json_output_string)
    output_fileh.writelines(json_output_string)
    output_fileh.close()
    return filepath

def convert_segmentlist_to_json(segmentlist_input):
    """ 
    Helper function used to convert segmentlist to json list of lists type 
    object.
    Utility method, ripped from jsonhelper.py in dqsegdb package, until we 
    can use it as a dependency.
    """
    json_list=[[x[0],x[1]] for x in segmentlist_input]
    return json_list

def convert_json_list_to_segmentlist(jsonlist):
    """ 
    Helper function used to convert JSON list of lists-type object to a 
    segmentlist object-
    Utility method, ripped from jsonhelper.py in dqsegdb package, until we 
    can use it as a dependency.
    """
    segment_list=segments.segmentlist([segments.segment(x[0],x[1]) for x in jsonlist])
    return segment_list

def parse_command_line():
    """
    Set the args that can be passed by the user at the command line.
    """
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('jsonfile', type=str, help="Json input file.")
    parser.add_argument('-o', '--output', help="Output file path")
    parser.add_argument('-t', '--type', default='vdb', help='Type of file to ouput, default: %(default)s')
    args = parser.parse_args()
    return args

if __name__ == "__main__":
    """
    The script starts here, parses the args passed by the user and then, 
    loads in the JSON payload, builds the header, builds the alternative 
    payload and then writes it to the output file.
    """
    args = parse_command_line()
    # Set the accepted formats.
    output_formats = ['vdb', 'ascii', 'coalesced_json', 'csv', 'tsv']
    # Raise an error if an errant output-format has been provided.
    if args.type not in output_formats:
        raise Exception('Please provide one of the following types: %s ' % (", ".join(output_formats)))
    try:
        json_dict = json.load(open(args.jsonfile))
    except:
        raise Exception('Unable to load JSON file: %s' % (args.jsonfile))
    else:
        # Get the length of the dictionary passed.
        json_dict_len = len(json_dict)
        # Set the header, dependent upon the length of the dictionary.
        if json_dict_len == 1:
            hdr = '# One Flag-Version (%d) requested:\n' % (int(json_dict[0]['version']))
        else:
            hdr = '# % Flag-Versions requested. %d results:\n' % (json_dict_len)
        # Handle ASCII- and tab-separated-value-type conversion.
        if args.type == 'ascii' or args.type == 'tsv':
            s = generate_ascii_tsv(json_dict, args.type)
        # Handle VDB-type conversion.
        elif args.type == 'vdb':
            s = generate_vdb(json_dict)
        # Handle Coalesced JSON conversion.
        elif args.type == 'coalesced_json':
            s = generate_coalesced_json(json_dict)
        # Open the output file and copy the results to it.
        try:
            f = open(args.output,'w')
        except:
            raise Exception('Problem opening file: %s' % (args.output))
        else:
            # Append the header and the results to the file and close off.
            f.write(hdr + s)
            f.close()
